///////////////////////////////////////////////////////////////////////////////
// Signal Type Logic Scripts
//
///////////////////////////////////////////////////////////////////////////////

// AM14Light
// BNSF3Light
// BNSF3LightA
// BNSF2Light
// OBBSemHome
// OBBSemDist
// JP3Light
// JP4Light
// UKSemHome
// UKSemDist

SCRIPT AM14Light

// Amtrak 14 Light Signal Head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		next_state;

// If required, show the appropriate 'stop' indication.
	if (!enabled ||						// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR ||		// Block ahead not clear?
		!route_set())					// Switch not set as per link?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else
	{
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP ||
			next_state ==# SIGASP_STOP_AND_PROCEED ||
			next_state ==# SIGASP_RESTRICTING)
		{
			state = SIGASP_APPROACH_1;
		}
		else if (next_state ==# SIGASP_APPROACH_1)
			 state = SIGASP_APPROACH_2;
		else if (next_state ==# SIGASP_APPROACH_2)
			 state = SIGASP_APPROACH_3;	 
		else
			state = SIGASP_CLEAR_2;
			
	}

// Get draw state
	draw_state = def_draw_state (state);



///////////////////////////////////////////////////////////////////////////////
SCRIPT BNSF3Light

// BNSF 3 light signal head

	// Use SIG_EXTERNS 'macro' instead?..
	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;

	has_number_plate	= sig_feature (SIGFEAT_NUMBER_PLATE);
	has_gradient_plate	= sig_feature (SIGFEAT_GRADIENT_PLATE);

// If required, show the appropriate 'stop' indication.
	if (!enabled ||								// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR ||		// Block ahead not clear?
		!route_set())							// Switch not set as per link?
	{
		if (has_gradient_plate)
			state = SIGASP_RESTRICTING;
		else if (has_number_plate)
			state = SIGASP_STOP_AND_PROCEED;
		else
			state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else
	{
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP ||
			next_state ==# SIGASP_STOP_AND_PROCEED ||
			next_state ==# SIGASP_RESTRICTING)
		{
			state = SIGASP_APPROACH_1;
		}
		else if (next_state ==# SIGASP_APPROACH_1)
		{
			state = SIGASP_APPROACH_2;
		}
		else //if (next_state ==# SIGASP_APPROACH_2 ||
			//	next_state ==# SIGASP_CLEAR_2)
		{
			state = SIGASP_CLEAR_2;
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

// Show the restricting indication with flashing red light if this signal does not
// have a gradient plate (it will be a constant red otherwise).
	if (state ==# SIGASP_RESTRICTING &&
		!has_gradient_plate)
	{
		draw_state = 1;					// (Draw state index from signal config)
	}

///////////////////////////////////////////////////////////////////////////////
SCRIPT BNSF3LightA

// BNSF 3 light signal head (ABS/Interval)

	// Use SIG_EXTERNS 'macro' instead?..
	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;

	has_number_plate	= sig_feature (SIGFEAT_NUMBER_PLATE);
	has_gradient_plate	= sig_feature (SIGFEAT_GRADIENT_PLATE);

// If required, show the appropriate 'stop' indication.
	if ( // !enabled ||							// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR ||		// Block ahead not clear?
		!route_set())							// Switch not set as per link?
	{
		if (has_gradient_plate)
			state = SIGASP_RESTRICTING;
		else //if (has_number_plate)
			state = SIGASP_STOP_AND_PROCEED;
		//else
		//	state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else
	{
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP ||
			next_state ==# SIGASP_STOP_AND_PROCEED ||
			next_state ==# SIGASP_RESTRICTING)
		{
			state = SIGASP_APPROACH_1;
		}
		else if (next_state ==# SIGASP_APPROACH_1)
		{
			state = SIGASP_APPROACH_2;
		}
		else //if (next_state ==# SIGASP_APPROACH_2 ||
			//	next_state ==# SIGASP_CLEAR_2)
		{
			state = SIGASP_CLEAR_2;
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

// Show the restricting indication with flashing red light if this signal does not
// have a gradient plate (it will be a constant red otherwise).
	if (state ==# SIGASP_RESTRICTING &&
		!has_gradient_plate)
	{
		draw_state = 1;					// (Draw state index from signal config)
	}

///////////////////////////////////////////////////////////////////////////////
SCRIPT BNSF2Light

// BNSF 2 light signal head

	// Use SIG_EXTERNS 'macro' instead?..
	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;

	has_number_plate	= sig_feature (SIGFEAT_NUMBER_PLATE);
	has_gradient_plate	= sig_feature (SIGFEAT_GRADIENT_PLATE);

// If required, show the appropriate 'stop' indication.
	if (!enabled ||								// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR ||		// Block ahead not clear?
		!route_set())							// Switch not set as per link?
	{
		if (has_gradient_plate)
			state = SIGASP_RESTRICTING;
		else if (has_number_plate)
			state = SIGASP_STOP_AND_PROCEED;
		else
			state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else
	{
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP ||
			next_state ==# SIGASP_STOP_AND_PROCEED ||
			next_state ==# SIGASP_RESTRICTING)
		{
			state = SIGASP_APPROACH_1;
		}
		else //if (next_state ==# SIGASP_APPROACH_1) ||
			//	next_state ==# SIGASP_APPROACH_2 ||
			//	next_state ==# SIGASP_CLEAR_2)
		{
			state = SIGASP_APPROACH_2;
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

// Show the restricting indication with flashing red light if this signal does not
// have a gradient plate (it will be a constant red otherwise).
	if (state ==# SIGASP_RESTRICTING &&
		!has_gradient_plate)
	{
		draw_state = 1;					// (Draw state index from signal config)
	}


///////////////////////////////////////////////////////////////////////////////
SCRIPT OBBSemDist

// OBB Semephore Signal distance arm

	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	dist_multi_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	if ( //!enabled ||							// Not enabled/cleared to show natural state?
		!route_set() ||							// Switch not set as per link?
		dist_multi_sig_mr (SIGFN_NORMAL, SIGFN_DISTANCE) ==# SIGASP_STOP)
	{
		state = SIGASP_APPROACH_2;
	}
	else
	{
		state = SIGASP_CLEAR_2;
	}

// Get draw state
	draw_state = def_draw_state (state);


//////////////////////////////////////////////////////////////////////////////////////
SCRIPT OBBSemHome

// OBB Semephore Signal home arm

	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	if (!enabled ||								// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR ||				// Block ahead not clear?
		!route_set())							// Switch not set as per link?
	{
		state = SIGASP_STOP;
	}
	else
	{
		state = SIGASP_CLEAR_2;
	}

// Get draw state
	draw_state = def_draw_state (state);


///////////////////////////////////////////////////////////////////////////////
SCRIPT JP3Light

// Japanese 3 light signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

// If required, show the 'stop' indication.
	if (!enabled ||								// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR ||		// Block ahead not clear?
		!route_set())							// Switch not set as per link?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else
	{
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP)
		{
			state = SIGASP_APPROACH_3;
		}
		else // if (next_state ==# SIGASP_APPROACH_3 ||
			//   next_state ==# SIGASP_CLEAR_2)
		{
			state = SIGASP_CLEAR_2;
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT JP4Light

// Japanese 4 light signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

// If required, show the 'stop' indication.
	if (!enabled ||								// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR ||		// Block ahead not clear?
		!route_set())							// Switch not set as per link?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else
	{
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP)
		{
			state = SIGASP_APPROACH_2;
		}
		else if (next_state ==# SIGASP_APPROACH_2)
		{
			state = SIGASP_APPROACH_3;
		}	
		else //if (next_state ==# SIGASP_APPROACH_3 ||
			//   next_state ==# SIGASP_CLEAR_2)
		{
			state = SIGASP_CLEAR_2;
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

SCRIPT UKSemHome

// UK Semephore (Home)

	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	if (!enabled ||								// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR ||		// Block ahead not clear?
		!route_set())							// Switch not set as per link?
	{
		state = SIGASP_STOP;
	}
	else
	{
		state = SIGASP_CLEAR_2;
	}

// Get draw state
	draw_state = def_draw_state (state);


///////////////////////////////////////////////////////////////////////////////
SCRIPT UKSemDist

// UK Semephore (Distance)

	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	dist_multi_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	if ( //!enabled ||							// Not enabled/cleared to show natural state?
		!route_set() ||							// Switch not set as per link?
		dist_multi_sig_mr (SIGFN_NORMAL, SIGFN_DISTANCE) ==# SIGASP_STOP)
	{
		state = SIGASP_APPROACH_2;
	}
	else
	{
		state = SIGASP_CLEAR_2;
	}

// Get draw state
	draw_state = def_draw_state (state);

